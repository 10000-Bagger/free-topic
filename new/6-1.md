## 웹어셈블리

> 회사에 WASM(웹어셈블리) 신천지인 개발자분한테 점심시간 내내 설교당하고나서
> WASM에 관한 내용을 공유해봅니다
>
> 아직 잘 모르는 내용이라 글이 정돈되지 못했지만 그냥 보셔요

### 자바스크립트
자바스크립트는 JIT 컴파일러를 사용하는 스크립트 언어라서 느릴 수 밖에 없음

> 느린 이유
> 1. 텍스트로 된 코드를 토큰 별로 분리
> 2. 토큰화된 정보로 추상구문트리(AST) 생성
> 3. AST를 기반으로 바이트 코드 생성
> 4. 생성된 바이트 코드를 기계어로 변경하는 작업
> 이 필요하기 때문에 느림

- 여기서 최적화 작업이 들어가면 더 복잡해짐
- 실행 초기: 최적화되지 않은 코드로 여러번 실행하면서 함수 실행에 소요된 시간을 추정 -> 최적화 하는게 얼마나 유용한지 예측
- 이에 따라 최적화하기로 결정한 hot function은 실시간으로 최적화 코드를 만들어냄
- 기존 실행 코드와 교체하는 작업을 진행

위 과정을 더 빠르게 실행할 수 있을까를 고민해서 나온게 바로 asm.js와 웹어셈블리

### asm.js
- 파이어폭스에서 구현한 스펙
- 특정 조건에 맞으면 기계어로 바로 컴파일해줌

``` js
function asmFunc() {
  "use asm";

  function plusOne(a) {
     return (a + 1)| 0;
  }
  return {plusOne: plusOne};
}
```

- `"use asm"`이라는 디렉티브를 사용
   - `use strict` 느낌이라고 생각하시면 됨 
- 브라우저가 해당 디렉티브를 보고 해당 함수를 기계어로 컴파일을 시도함
   - 아닌 경우는 그냥 일반 자바스크립트처럼 해석 

- 산술 연산의 최적화에만 맞춘 기능이라 `|`나 기호를 사용해서 변수 타입을 알려줘야함
   - `(a + 1)| 0` 이런 식으로 작성해야 파이어폭스에서 기계어로 컴파일을 시도

- 이러한 웹 최적화를 파이어폭스가 시작했지만, 이후 다른 브라우저에서도 `use asm`이라는 디렉티브를 만났을 때 최적화를 시도하는 기능을 개발
- 하지만 이러면 브라우저마다 다르게 동작하니까 통합적인 표준이 필요했음
- 따라서, W3C에서 표준으로 WebAssembly를 만들게 됨


### WebAssembly
- 동일한 자바스크립트 코드에 비해 더 빠르게 실행됨
  - JS는 WASM보다 파일 크기가 큼
  - 파싱 및 타입 추론 필요
  - JIT 필요
- WASM은 IR(Itermediate Representation)으로 작성되어서 파싱 없이 그대로 메모리에 적재하면 됨
  - 타입 추론 불필요 (이미 들어있음)
  - 각 언어마다 .wasm 파일을 생성하면서 컴파일러가 정적 언어의 최적화를 적용 -> 브라우저 최적화 기법의 영향을 덜 받음

### WASI
- 웹 어셈블리를 기반으로 만든 플랫폼(cpu, os)에 상관없이 작동하는 인터페이스 규약
- 기존에 웹에서만 사용했던 WASM을 모든 플랫폼에서 사용할 수 있음
- 권한받은 폴더에 한해서 시스템 콜도 가능
